ctrl+alt+T 打开终端
### linux如何关闭命令行正在执行的命令
- ctrl+c 终止进程
- ctrl+d 退出
- ctrl+s 挂起
- CTRL+q 解挂
- ctrl+z 强制结束

杀死进程最安全的方法是单纯使用kill命令，不加修饰符，不带标志。
- 首先使用ps -ef命令确定要杀死进程的PID，然后输入以下命令： kill -pid
- ps -ef|grep 进程名  //查看运行了哪些进程，注释：标准的kill命令通常都能达到目的。终止有问题的进程，并把进程的资源释放给系统。然而，如果进程启动了子进程，只杀死父进程，子进程仍在运行，因此仍消耗资源。为了防止这些所谓的“僵尸进程”，应确保在杀死父进程之前，先杀死其所有的子进程。 
- kill -l pid //-l选项告诉kill命令用好像启动进程的用户已注销的方式结束进程。当使用该选项时，kill命令也试图杀死所留下的子进程。但这个命令也不是总能成功--或许仍然需要先手工杀死子进程，然后再杀死父进程。 
- killall  命令杀死同一进程组内的所有进程。其允许指定要终止的进程的名称，而非PID。
- kill -HUP PID   //该命令让Linux和缓的执行进程关闭，然后立即重启。在配置应用程序的时候，这个命令很方便，在对配置文件修改后需要重启进程时就可以执行此命令。 
- kill -9 PID  //这个强大和危险的命令迫使进程在运行时突然终止，进程在结束后不能自我清理。危害是导致系统资源无法正常释放，一般不推荐使用，除非其他办法都无效。
//当使用此命令时，一定要通过ps -ef确认没有剩下任何僵尸进程。只能通过终止父进程来消除僵尸进程。如果僵尸进程被init收养，问题就比较严重了。杀死init进程意味着关闭系统。
//如果系统中有僵尸进程，并且其父进程是init，而且僵尸进程占用了大量的系统资源，那么就需要在某个时候重启机器以清除进程表了。

## 僵尸进程和孤儿进程
### 基本概念
> 僵尸进程：是所有进程都会进入的一种进程状态，子进程退出，而父进程并没有调用 wait() 或 waitpid() 获取子进程的状态信息，那么子进程的 PID 和 进程描述符 等资源仍然保存在系统中，这种进程称之为僵尸进程。僵尸进程会一直以终止状态（释放了内存等资源）保持在进程表里并会一直等待父进程获取其退出状态，但父进程没有回收（父进程出了问题）。
> 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程（CentOS7 中是 systemd 进程，进程号为 1）所收养，并由 init 进程对它们完成状态收集工作 。

### 问题及危害
#### 僵尸进程
如果进程不调用 wait()/waitpid() 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号（或者句柄）而导致系统不能产生新的进程， 此即为僵尸进程的危害，应当避免 。
任何一个子进程（init 除外）在 exit() 之后，都会留下一个称为僵尸进程（Zombie）的数据结构 。

#### 孤儿进程
孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了 init 进程（或者 systemd 进程）身上，init 进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作，因此孤儿进程并不会有什么危害。
重复强调，任何一个子进程（init 除外）在 exit() 之后，并非马上就消失掉，而是留下一个称为僵尸进程（Zombie）的数据结构，等待父进程处理 。

#### 解决僵尸进程
僵尸进程的出现，追其根本原因，是其父进程出现了问题，在子进程 exit() 后没有回收子进程的资源，而不是 Linux 系统的问题；此时运行的程序代码逻辑应该是有问题的，需要整改，如果出现僵尸进程，可以通过以下两种方法解决，第一种方法一般不好用：

Copy
# 方法一，传递信号给其父进程，命令其回收子进程的资源
kill -CHLD  + 父进程号

# 方法二，直接 KILL 掉其父进程，将此进程变成孤儿进程，交给 init 进程管理，init 进程回收此进程的资源
kill -9 + 父进程号

## 指令的标准格式
指令 [选项][操作对象]
一个指令可以包含多个选项
操作对象也可以是多个

### 基础指令
1. ls指令
  ls  [选项][目录名]
 - 不带任何参数，列出当前工作目录的内容
 - /etc 列出任何目录的内容
 - -a: 展示目录中的所有文件，连同隐藏档一起列出来
 - -A：全部的档案，连同隐藏档，但不包括.与..这两个目录，一起列出来
 - -d：仅列出目录本身，而不是列出目录内的档案数据
 - -f：直接列出结果，而不进行排序（ls预设会以档名排序）
 - -F：根据档案、目录等信息，给予附加数据结果例如： *：代表可执行档； /：代表目录； =：代表 socket 档案； |：代表 FIFO 档案； 
 - -h ：将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来； 
 - -i ：列出 inode 位置，而非列出档案属性； 
 - -l ：长数据串行出，包含档案的属性等等数据，显示文件及其详细信息； 
 - -n ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在账号管理提到！) 
 - -r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小； 
 - -R ：连同子目录内容一起列出来； 
 - -S ：以文档大小排序！ 
 - -t ：依时间排序 
 - --color=never ：不要依据档案特性给予颜色显示； 
 - --color=always ：显示颜色 
 - --color=auto ：让系统自行依据设定来判断是否给予颜色 
 - --full-time ：以完整时间模式 (包含年、月、日、时、分) 输出 
 - --time={atime,ctime} ：输出 access 时间或 改变权限属性时间 (ctime) 而非内容变更时间 (modification time) 

