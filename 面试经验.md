腾讯PCG：怎么理解TCP是流式传输的？
这个和代码无关，主要是BB能力。
先解释这个流式传输的这个流：简单来说，流式传输中的流，主要指的是TCP要把传的数据视为字节流，至于这些字节是什么含义，TCP不管，由上层应用操心。
还有另外一个原因：（这个原因一定要记住了） 和流式传输是有关系的，TCP是可靠传输的，所以TCP可以用来传送一个大文件，此时这个大文件就是一串有序的字节，也就叫做字节流。
联系到我自己做的项目的话，UDP发的就是一个报文一个报文的短消息，且每个消息是一个完整的个体，之间没有任何关联，从这个意义上来说，UDP发的不是流。所以我们才可以把一个个包初始化为一个个类。


## STL的二级空间配置器
https://blog.csdn.net/dawn_sf/article/details/78774275?ref=myread?ops_request_misc=&request_id=&biz_id=102&utm_term=STL-%E6%B5%85%E6%9E%90%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-78774275


虎牙面试：电话面试

A调B，B调C。调用栈的问题：

https://blog.csdn.net/wangyin668/article/details/79769151

注意这里有一个栈帧的概念：

栈帧里面包含所有的函数参数和返回地址

被调用者生成这样的栈帧，

调用者做两件事情：

1.将被调用函数的参数按照从右到左的顺序压入栈中，

2.将返回地址也压入栈中

8.C++的新特性：右值引用

基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率；

std::move是怎么实现的？

​std::move并不能移动任何东西，它唯一的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。

​从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);

例子：

std::move(foo);  //使用std::move返回foo的右值引用

```
std::vector<std::unique_ptr<T>>
在容器std::vector中放入了不可复制只能移动的类的对象(std::unique_ptr)
因为std::unique_ptr的拷贝构造函数是被删除的
```

右值引用和左值引用的本质区别？

实际上二者在编译后的汇编层面，就是变量的地址，没有任何区别。为什么“画蛇添足”增加右值引用这个概念？

因为要在编译时告诉编译器，这里传入的 “变量的地址”，是个普通变量还是濒死的除了此处不再使用的变量。如果是后者，可以用move语义，直接把它的内容、资源给搬走，不用“深拷贝”了。

对于函数模板void G(A &&a)，它的内部怎么知道形参对应的实参，是一个普通变量，还是濒死的临时变量？

​不知道的话，就原封不动的完美转发给函数模板，用std::forward

​而且实际上std::forward啥也不做，就是取变量的地址而已。